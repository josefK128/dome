{"version":3,"names":[],"mappings":"","sources":["components/i3d/i3d-particlesystem-directive.js"],"sourcesContent":["// * i3d-particlesystem-directive.js\n// * creates three.js component registered with Camera3d and added to scene<br>\n//   pass in params as attrs\n//\n// * @dependencies: Camera3d, Transform3d<br>\n//   @param {services/camera3d-service.js} Camera3d<br>\n//   @param {services/transform3d-service.js} Transform3d<br>\n//   @param {services/log-service.js} Log<br>\n//   @param {utils/colourToHex.js} colourToHex<br>\n//   @ngInject\n//\n// * NOTE: ngInject is used by ngAnnotate to generate a \n//   minification-safe injection annotation such as:\n//   ```function($scope) => ['$scope', function($scope){}]```\n//\n// * NOTE:uses attribute to initialize GPUParticleSystem2.js, a slight\n//   modification of three.js GPUParticleSystem.js to allow declarative\n//   configuration of particle system via this directive\n// * NOTE: Camera3d.addActorToScene(pid, id, node) adds the node as a child to \n//   Camera3d.actor[pid] if pid is defined,\n//   and as a child of webgl scene otherwise (i.e. if root)\n// * NOTE: all work constructing the node (THREE.js Object3d) is done in pre-link\n//   function since pre-links are run after controller constructor and in\n//   root-to-leaf order so that correct relative transforms are computed in webgl\n//   RECALL: link-fs (===post-link-fs) are run in leaf-to-root order!! \n// * NOTE: controller must use services for $scope $element and $attrs whereas\n//   pre-link (and post-link) receive these three args (in order) as well as\n//   a fourth arg instance of the controller\n// * NOTE: $destroy occurs when the angular jQuery wrapper is destroyed.\n//   Thus the wrapper is removed from the DOM but not the 'raw' DOM element\n//   nor, more importantly, the webgl node in the underlying webgl scenegraph\n\n\nangular.module('app').directive(\"i3dParticlesystem\", [\"Camera3d\", \"Transform3d\", \"Log\", \"colourToHex\", function(Camera3d, \n  Transform3d, Log, colourToHex){\n  \"use strict\";\n\n  \n  // return DDO<br>\n  // scope:true => unique micro-scope for each i3d-node - see pid NOTE\n  return {\n    restrict: 'E',\n    scope: 'true', \n    replace: 'false',\n    templateNamespace: 'svg',\n    compile: function(elem, attrs){\n\n      // vars used by pre-link-f and (trivially) by post-link-f\n      // * NOTE attrs  are all strings! - for safety must convert values<br>\n      //   strings do NOT work as boolean values in Material for exp.<br>\n      //   objects form and transform must converted by ```JSON.parse```\n      // particlesystem vars\n      var scene = Camera3d.scene(),\n          particleSystem,\n          maxParticles = 10000,\n          textureUrl = 'images/p2.jpg',\n          transform = {t: [0.0,-50.0,0.0]},\n          transl = transform['t'],\n          // options\n          options,\n      \t  position = new THREE.Vector3(transl[0],transl[1],transl[2]),\n          positionRandomness = 0.3,\n          velocity = new THREE.Vector3(1.0, 1.0, 1.0),  // was 0,0,0 !\n          velocityRandomness = 0.5,\n          size = 5,\n          sizeRandomness = 1,\n          color = '0xaa88ff',\n          colorRandomness = 0.2,\n          turbulence = 0.5,\n          lifetime = 2, \n          // spawnerOptions\n          spawnerOptions,\n          spawnRate = 100,\n          horizontalSpeed = 1.5,\n          verticalSpeed = 1.33,\n          timeScale = 1,\n          // animation\n          tick = 0,\n          clock = new THREE.Clock(true),\n          r = 0.0,\n          s = 0.0,\n          y = 0.0,\n          TWOPI = 6.28,\n          // gui\n          gui = new DAT.GUI({\n            height: 9*32-1  // nlines*32-1\n          }),\n          realize = (id, pid, transform) => {\n\n            // add the Object3d to the scene and store in Camera3d actors by id\n            Camera3d.addActorToScene(id, particleSystem, pid);\n            console.log(`added to scene particlesystem with texture ${textureUrl}`);\n            console.log(`particlesystem has id = ${id}`);\n      \n            // transform particleSystem - relative to parent in THREE.js scene !!!\n            Transform3d.apply(transform, particleSystem);\n          },\n          //pre-link runs root-to-leaf\n          prelink = (scope, elem, attrs) => {\n    \n            // NOTE! attrs are all strings! - convert via JSON.parse!<br>   \n            // pid is 'parent-id'\n            var id = attrs.id,\n                p = scope.p || {},\n                pid = p.pid,\n                tr = JSON.parse(attrs.transform),\n                form = JSON.parse(attrs.form),\n                o,\n                spo,\n                t,\n                v,\n                q;\n\n            // short vars\n            if(form){\n              o = form['options']; \n              spo = form['spawnerOptions']; \n            }\n\n\n            // diagnostics\n//            if(tr){\n//              console.log(`tr['t'] = ${tr['t']}`);\n//            }else{\n//              console.log(`tr['t'] does not exist!`);\n//            }\n//\n//            if(o){\n//              for(q in o){\n//                if(o.hasOwnProperty(q)){\n//                  console.log(`attrs.form.options has property ${q}`);\n//                }\n//              }\n//            }else{\n//              console.log(`attrs.form.options does not exist!`);\n//            }\n//\n//            if(spo){\n//              for(q in spo){\n//                if(spo.hasOwnProperty(q)){\n//                  console.log(`attrs.form.spawnerOptions has property ${q}`);\n//                }\n//              }\n//            }else{\n//              console.log(`attrs.form.spawnerOptions does not exist!`);\n//            }\n\n            // declarative attr-values from model OR defaults (from above) \n            // particlesystem vars\n            if(tr){\n              transform = tr || transform; // for Transform3d - object\n              t = tr.t;\n              console.log(`setting position t = ${t}`);\n              position = new THREE.Vector3(t[0],t[1],t[2]);\n            }\n            if(form){\n              console.log('setting maxParticles and textureUrl');\n              console.log(`form.maxParticles = ${form.maxParticles}`);\n              console.log(`form.textureUrl = ${form.textureUrl}`);\n              maxParticles = form.maxParticles || maxParticles;\n              textureUrl =  form.textureUrl || textureUrl;\n              // options\n              if(o){\n                console.log('setting options');\n                for(q in o){\n                  if(o.hasOwnProperty(q)){\n                    console.log(`options has pr ${q} val ${o[q]}`);\n                  }\n                }\n                positionRandomness = o.positionRandomness || positionRandomness;\n                if(o.velocity){\n                  v = o.velocity;\n                  velocity = new THREE.Vector3(v[0], v[1], v[2]) || velocity;  \n                }\n                velocityRandomness = o.velocityRandomness || velocityRandomness;\n                size = o.size || size ;\n                sizeRandomness = o.sizeRandomness || velocityRandomness;\n                color = o.color || color;\n                colorRandomness = o.colorRandomness || colorRandomness;\n                turbulence = o.turbulence || turbulence;\n                lifetime = o.lifetime || lifetime;\n              }\n              // spawnerOptions\n              if(spo){\n                console.log('setting spawnerOptions');\n                for(q in spo){\n                  if(spo.hasOwnProperty(q)){\n                    console.log(`spawnerOptions has pr ${q} val ${spo[q]}`);\n                  }\n                }\n                spawnRate = spo.spawnRate || spawnRate;\n                horizontalSpeed = spo.horizontalSpeed || horizontalSpeed;\n                verticalSpeed = spo.verticalSpeed || verticalSpeed;\n                timeScale = spo.timeScale || timeScale;\n              }\n            }\n\n\n            // convert color name to hex for use in three.js material\n            if(!/^(#|0x)/.test(color)){\n              console.log(`convert to hex color = ${color}`);\n              color = colourToHex(color);\n            }\n\n\n            // GPU particlesystem - init\n            // The GPU Particle system extends THREE.Object3D, and so you can use it\n            // as you would any other scene graph component.\tParticle positions will be\n            // relative to the position of the particle system, but you will probably only need one\n            // system for your whole scene\n            particleSystem = new THREE.GPUParticleSystem({\n            \tmaxParticles: maxParticles,\n              texture: textureUrl\n            });\n      \n            // options passed during each spawned\n            options = {\n            \tposition: position,\n            \tpositionRandomness: positionRandomness,\n            \tvelocity: velocity,\n            \tvelocityRandomness: velocityRandomness,\n            \tcolor: color,\n            \tcolorRandomness: colorRandomness,\n            \tturbulence: turbulence,\n            \tlifetime: lifetime,\n            \tsize: size,\n            \tsizeRandomness: sizeRandomness\n            };\n            spawnerOptions = {\n            \tspawnRate: spawnRate,        \n            \thorizontalSpeed: horizontalSpeed,\n            \tverticalSpeed: verticalSpeed,\n            \ttimeScale: timeScale\n            };\n      \n            // init gui\n            gui.add(options, \"velocityRandomness\", 0, 3);\n            gui.add(options, \"positionRandomness\", 0, 3);\n            gui.add(options, \"size\", 1, 20);\n            gui.add(options, \"sizeRandomness\", 0, 25);\n            gui.add(options, \"colorRandomness\", 0, 1);\n            gui.add(options, \"lifetime\", 0.1, 10);\n            gui.add(options, \"turbulence\", 0, 1);\n            gui.add(spawnerOptions, \"spawnRate\", 10, 10000);\n            gui.add(spawnerOptions, \"timeScale\", -1, 1);\n            \n            // add specific animation for particle system to object of\n            // frame-update animations called fr Camera3D in its animation loop\n            if(!scene['animations']){\n              scene['animations'] = {};\n            }\n            scene['animations'][id] = () => {\n              var delta = clock.getDelta() * spawnerOptions.timeScale;\n              tick += delta;\n              if (tick < 0){ \n                tick = 0;\n              }\n              if (delta > 0) {\n                if(y > 50.0){\n                  y = -50 + Math.random();\n                  r = 2.0 + Math.random();\n                  s = Math.random();\n                }else{\n                  r += 2.0 * Math.random();\n                  s += 0.1 * Math.random();\n                  y += 4.0 * spawnerOptions.verticalSpeed * Math.max(r,s);   // was 4.0\n                }\n                options.position.x = r*Math.sin(s * TWOPI);\n                options.position.y = y;                   \n                options.position.x = r*Math.cos(s * TWOPI);\n          \n                for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {\n              \t// Yep, that's really it.\tSpawning particles is super cheap, and once you spawn them, the rest of\n              \t// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below\n              \tparticleSystem.spawnParticle(options);\n                }\n              }\n\n              particleSystem.update(tick);\n            };\n    \n              \n            // diagnostics\n            console.log(\"added particlesystem update f to scene['animations']\");\n//            console.log(`scene['animations'] = ${scene['animations']}`);\n//            if(scene['animations']){\n//              for(let f of Object.keys(scene['animations'])){\n//                console.log(`scene['animations'] has pr f = ${f}`);\n//                console.log(`scene['animations'][f] = ${scene['animations'][f]}`);\n//                scene['animations'][f]();\n//              }\n//            }\n    \n            // clear and set $scope.p.pid = id for subsequent children<br>\n            // $scope.p is a different object for each level \n            scope.p = {};\n            scope.p.pid = id;\n            // add actor to scene\n            realize(id, pid, transform);\n    \n            // cleanup\n            elem.on(\"$destroy\", function() {\n              console.log(`particle system ${id} removing animation function`);\n              delete scene['animations'][id];\n            });\n    \n          },//pre-link runs root-to-leaf\n          //post-link runs leaf-to-root\n          postlink =  (scope, elem, attrs) => {\n          };//post-link\n      \n      // compile returns link={pre,post}\n      return {\n        pre: prelink,\n        post: postlink\n      };\n    }//compile\n  };//return DDO\n}]);\n\n"],"file":"components/i3d/i3d-particlesystem-directive.js","sourceRoot":"/source/"}